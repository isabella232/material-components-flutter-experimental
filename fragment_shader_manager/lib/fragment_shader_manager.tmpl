{{generatedCodeHeader}}

// Copyright 2021 The Flutter team. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:vector_math/vector_math_64.dart';

/// A class for managing [FragmentProgram] that includes a pre-transpiled
/// shader program into SPIR-V.
{{#glslAsDocCommentFlag}}
///
/// GLSL source for this shader:
///
{{glslDocComment}}
{{/glslAsDocCommentFlag}}
class FragmentShaderManager {
  FragmentShaderManager._();

  /// Creates an [FragmentShaderManager] with an [{{constructorName}}] effect.
  static Future<FragmentShaderManager> {{constructorName}}() async {
    final manager = FragmentShaderManager._();
    await manager.compile();
    return manager;
  }

  /// Compiles the spir-v bytecode into a shader program.
  Future<void> compile() async {
    _program = await ui.FragmentProgram.compile(spirv: spirvByteBuffer);
  }

  /// Creates a shader with the original program and optional uniforms.
  /// 
  /// A new shader must be made whenever the uniforms are updated.
  Shader shader({
  {{#uniforms.entries}}
    {{value.type}}? {{value.name}},
  {{/uniforms.entries}}
  }) {
    return _program.shader(
      floatUniforms: Float32List.fromList([
      {{#uniforms.entries}}
        ...{{value.name}} != null ? {{value.toFloatTemplatePrefix}}{{value.name}}{{value.toFloatTemplateSuffix}} : {{value.defaultValue}},
      {{/uniforms.entries}}
      ]),
    );
  }
  
  late ui.FragmentProgram _program;

  /// Direct access to the [ui.FragmentProgram] that this class manages.
  /// 
  /// In general, this is not needed, but may be useful for debugging or edge cases.
  ui.FragmentProgram get program => _program;

  {{#glslAsConstFlag}}
  /// Direct access to the source GLSL that was used to generate this class.
  /// 
  /// In general, this is not needed, but may be useful for debugging or edge cases.
  String get glsl => _glslString;
  {{/glslAsConstFlag}}

  /// Direct access to the the SPIR-V bytecode that was used to generate this class.
  /// 
  /// In general, this is not needed, but may be useful for debugging or edge cases.
  ///
  /// Words in SPIR-V are 32 bits. Every 4 elements in this list represents 1
  /// SPIR-V word. See https://www.khronos.org/registry/SPIR-V/.
  ByteBuffer get spirvByteBuffer => Uint8List.fromList(_spirvByteList).buffer;
}

{{#glslAsConstFlag}}
  const _glslString = '''
{{glslString}}
''';
{{/glslAsConstFlag}}

/// {{byteCount}} bytes
/// TODO(clocksmith): Compress each word into an int to compress.
const _spirvByteList = {{spirvByteList}};
